{"meta":{"title":"Daniel的博客","subtitle":"","description":"随手记录自己的学习过程","author":"Daniel·young","url":"https://ymagic.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-07-05T11:28:12.668Z","updated":"2022-07-05T11:28:12.668Z","comments":false,"path":"/404.html","permalink":"https://ymagic.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2022-07-08T02:39:24.723Z","updated":"2022-07-05T11:28:12.669Z","comments":false,"path":"books/index.html","permalink":"https://ymagic.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-07-05T13:58:43.704Z","updated":"2022-07-05T11:28:12.668Z","comments":false,"path":"about/index.html","permalink":"https://ymagic.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2022-07-07T08:57:56.948Z","updated":"2022-07-05T11:28:12.669Z","comments":false,"path":"categories/index.html","permalink":"https://ymagic.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-07-06T06:47:53.039Z","updated":"2022-07-05T11:28:12.669Z","comments":false,"path":"repository/index.html","permalink":"https://ymagic.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-07-08T02:50:17.629Z","updated":"2022-07-05T11:28:12.669Z","comments":true,"path":"links/index.html","permalink":"https://ymagic.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-07T08:58:13.294Z","updated":"2022-07-05T11:28:12.669Z","comments":false,"path":"tags/index.html","permalink":"https://ymagic.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"缓存击穿、穿透和雪崩","slug":"缓存击穿、穿透和雪崩","date":"2022-04-25T12:05:01.000Z","updated":"2022-08-25T06:33:04.966Z","comments":true,"path":"2022/04/25/huan-cun-ji-chuan-chuan-tou-he-xue-beng/","link":"","permalink":"https://ymagic.github.io/2022/04/25/huan-cun-ji-chuan-chuan-tou-he-xue-beng/","excerpt":"","text":"缓存穿透 在高并发下，查询一个不存在的值时，缓存不会被命中，导致大量请求直接落到数据库上。缓存穿透就是指，高并发下请求的是缓存和数据库中都没有的数据！ 对于缓存穿透问题，有一个很简单的解决方案，就是缓存null值，从缓存取不到的数据，在数据库中也没有取到，直接返回空值。 spring-cache中有个配置是这样的spring.cache.redis.cache-null-values=true 带上该配置后，就可以缓存null值了，值得一提的是，这个缓存时间要设置的少一点，例如15秒就够，如果设置过长，会导致正常的缓存也无法使用 缓存击穿 在高并发下，对一个特定的值进行查询，但是这个时候缓存正好过期了，缓存没有命中，导致大量请求直接落到数据库上。缓存击穿是指，高并发下请求的是缓存没有，而数据库中有的数据！ 解决缓存击穿的最简单的方法就是限流，至于怎么限，其实可以各显神通！ 这里就要说spring-cache的另一个配置了！ 在缓存过期之后，如果多个线程同时请求对某个数据的访问，会同时去到数据库，导致数据库瞬间负荷增高。Spring4.3为@Cacheable注解提供了一个新的参数“sync”（boolean类型，缺省为false），当设置它为true时，只有一个线程的请求回去到数据库，其他线程都会等待直到缓存可用。这个设置可以减少对数据库的瞬间并发访问。 所以解决方法就是，加一个属性sync=true， 就行。代码如下@Cacheable(cacheNames=&quot;menu&quot;, sync=&quot;true&quot;)用了该属性后，可以指示底层将缓存锁住，使只有一个线程可以进入计算，而其他线程堵塞，直到返回结果更新到缓存中。 当然，到这里，可能有人会抬杠！你这个只是针对单机的限流，并不是整个集群的限流！假设你的集群搭建了3000个pod，最差的情况下就是，3000个pod上，每个pod都会发起一个请求去数据库查询，照样还是会导致数据库连接数不够用，等等资源问题！ 如果非要解决，也有办法。spring的aop有套路的，比如@Transactional的Advice是TransactionInterceptor，那么cache也对应一个CacheInterceptor, 我们只要去改CacheInteraceptor，这个切面就能解决，在里头做一个分布式锁！伪代码如下 123456flag = 取分布式锁if (flag) &#123; 走数据库查询，并缓存结果&#125; else &#123; 睡眠一段时间，再次尝试获取key的值&#125; 但是，真没有必要～～ 立足实际出发，但凡你的业务到了那种级别，是可以做到区域部署的，完全可以规避这类问题。 缓存雪崩 在高并发下，大量的缓存key在同一时间失效，导致大量的请求落到数据库上。那么针对该问题，最简单的解决方法就是，过期的时间加随机值！ 但是很麻烦的是，我们在使用@Cacheable注解的时候，原生功能没法直接设置随机过期时间的。 老实说，这个真没啥好方法，只能自己继承RedisCache，对其增强，改写其中的put方法，带上随机时间！","categories":[{"name":"缓存","slug":"缓存","permalink":"https://ymagic.github.io/categories/%E7%BC%93%E5%AD%98/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"https://ymagic.github.io/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"homebrew","slug":"homebrew","date":"2022-01-21T03:28:50.000Z","updated":"2022-08-25T06:34:33.789Z","comments":true,"path":"2022/01/21/homebrew/","link":"","permalink":"https://ymagic.github.io/2022/01/21/homebrew/","excerpt":"","text":"标签 Homebrew 的两个术语： Formulae：软件包，包括了这个软件的依赖、源码位置及编译方法等； Casks：已经编译好的应用包，如图形界面程序等。 Homebrw相关的几个文件夹用途： bin：用于存放所安装程序的启动链接（相当于快捷方式） etc：brew安装程序的配置文件默认存放路径 Library：Homebrew 系统自身文件夹 Cellar：通过brew安装的程序将以 [程序名/版本号] 存放于本目录下 常用的 brew 命令： 查看brew版本：brew -v 更新brew版本：brew update 本地软件库列表：brew list 查看软件库版本：brew list --versions 查找软件包：brew search xxx （xxx为要查找软件的关键词） 安装软件包：brew install xxx （xxx为软件包名称） 卸载软件包：brew uninstall xxx 安装软件：brew install xxx --cask（xxx为软件名称） 卸载软件：brew cask uninstall xxx 查找软件安装位置：which xxx （xxx为软件名称） （brew install 用来安装一些不带界面的命令行工具和第三方库；brew cask install 用来安装一些带界面的应用软件） 1. brew install brew 的官方网站： http://brew.sh/ 在官方网站对brew的用法进行了详细的描述 安装方法： 在Mac中打开Termal: 输入命令： /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot; 对于对程序员只需通过简单的指令，就能快速安装和升级本地的各种开发环境，非常快捷方便。","categories":[{"name":"homebrew","slug":"homebrew","permalink":"https://ymagic.github.io/categories/homebrew/"}],"tags":[{"name":"homebrew","slug":"homebrew","permalink":"https://ymagic.github.io/tags/homebrew/"}]},{"title":"mac安装openjdk17","slug":"mac安装openjdk17","date":"2021-12-08T15:45:03.000Z","updated":"2022-08-25T06:35:27.943Z","comments":true,"path":"2021/12/08/mac-an-zhuang-openjdk17/","link":"","permalink":"https://ymagic.github.io/2021/12/08/mac-an-zhuang-openjdk17/","excerpt":"","text":"声明：不适用于M1芯片的mac系列。 本文将使用mac的安装软件管理神器–&gt;Homebrew，请自行按官网步骤安装。 安装并配置 JDK 安装Openjdk brew search openjdk 后会出现如图中的情况 可以使用brew info openjdk@17 看一下openjdk@17的安装信息。 Dependencies 为brew 安装openjdk@17需要依赖的其他package Analytics 为openjdk@17现阶段的安装统计相关的信息 下面直接安装brew install openjdk@17 。安装的时间取决于网速的快慢。 配置jdk Mac 下如果让你安装的JDK 生效及可识别需要如下几步操作。 执行如下命令 sudo ln -sfn /usr/local/opt/openjdk@17/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-17.jdk 检查tree /Library/Java 12345➜ ~ tree /Library/Java/Library/Java├── Extensions└── JavaVirtualMachines └── openjdk-17.jdk -&gt; /usr/local/opt/openjdk@17/libexec/openjdk.jdk 执行/usr/libexec/java_home 12➜ ~ /usr/libexec/java_home/usr/local/Cellar/openjdk@17/17.0.3/libexec/openjdk.jdk/Contents/Home 多版本jdk切换 配置环境 Mac 下通过 bash_profile 文件来对环境信息进行配置。执行以下命令打开配置文件：vim ~/.bash_profile 根据环境变量信息新增JDK几个版本的相关内容 123456789101112# Java Config : Java家配置export JAVA8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_301.jdk/Contents/Homeexport JAVA17_HOME=/Library/Java/JavaVirtualMachines/openjdk-17.jdk/Contents/Home# config alias: 配置别名alias jdk8=&quot;export JAVA_HOME=$JAVA8_HOME&quot;alias jdk17=&quot;export JAVA_HOME=$JAVA17_HOME&quot;# config default :jdk 配置默认JDKexport JAVA_HOME=$JAVA8_HOMEexport PATH=&quot;$JAVA_HOME:$PATH&quot;export PATH=$&#123;PATH&#125;:$&#123;JAVA_HOME&#125;/bin 保存上述的配置，对.bash_profile进行编译生效 source ~/.bash_profile 然后在终端执行java -version 会发现jdk版本正常显示为jdk8 任意切换Jdk环境 如需要将 jdk 版本切换为 jdk17，直接输入 JDK17 环境变量的别名：jdk17 即可,然后查看版本，输入jdk8则切换到jdk8版本","categories":[{"name":"mac","slug":"mac","permalink":"https://ymagic.github.io/categories/mac/"},{"name":"openjdk","slug":"mac/openjdk","permalink":"https://ymagic.github.io/categories/mac/openjdk/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://ymagic.github.io/tags/mac/"},{"name":"openjdk","slug":"openjdk","permalink":"https://ymagic.github.io/tags/openjdk/"}]},{"title":"mac快捷键之iTerm2篇","slug":"mac快捷键之iTerm2篇","date":"2021-10-21T03:28:50.000Z","updated":"2022-08-25T06:35:58.229Z","comments":true,"path":"2021/10/21/mac-kuai-jie-jian-zhi-iterm2-pian/","link":"","permalink":"https://ymagic.github.io/2021/10/21/mac-kuai-jie-jian-zhi-iterm2-pian/","excerpt":"iterm2 常用的快捷键记录","text":"iterm2 常用的快捷键记录 标签 新建标签：⌘ + t 关闭标签：⌘ + w 切换标签：⌘ + 数字 ⌘ + 左右方向键 切换全屏：⌘ + enter 查找：⌘ + f 分屏 垂直分屏：⌘ + d 水平分屏：⌘ + shift + d 切换屏幕：⌘ + option + 方向键 ⌘ + [ 或 ⌘ + ] 查看历史命令：⌘ + ; 查看剪贴板历史：⌘ + shift + h 其他 清除当前行：ctrl + u 到行首：ctrl + a 到行尾：ctrl + e 前进后退：ctrl + f/b (相当于左右方向键) 上一条命令：ctrl + p 搜索命令历史：ctrl + r 删除当前光标的字符：ctrl + d 删除光标之前的字符：ctrl + h 删除光标之前的单词：ctrl + w 删除到文本末尾：ctrl + k 交换光标处文本：ctrl + t 清屏1：⌘ + r 清屏2：ctrl + l 很实用的功能/快捷键 ⌘ + 数字在各 tab 标签直接来回切换 选择即复制 + 鼠标中键粘贴，这个很实用 ⌘ + f 所查找的内容会被自动复制 ⌘ + d 横着分屏 / ⌘ + shift + d 竖着分屏 ⌘ + r = clear，而且只是换到新一屏，不会想 clear 一样创建一个空屏 ctrl + u 清空当前行，无论光标在什么位置 输入开头命令后 按 ⌘ + ; 会自动列出输入过的命令 ⌘ + shift + h 会列出剪切板历史 可以在 Preferences &gt; keys 设置全局快捷键调出 iterm，这个也可以用过 Alfred 实现 常用的快捷键 ⌘ + 1 / 2 左右 tab 之间来回切换，这个在 前面 已经介绍过了 ⌘← / ⌘→ 到一行命令最左边/最右边 ，这个功能同 C+a / C+e ⌥← / ⌥→ 按单词前移/后移，相当与 C+f / C+b，其实这个功能在Iterm中已经预定义好了，⌥f / ⌥b，看个人习惯了 设置方法如下 当然除了这些可以自定义的也不能忘了 linux 下那些好用的组合 C+a / C+e 这个几乎在哪都可以使用 C+p / !! 上一条命令 C+k 从光标处删至命令行尾 (本来 C+u 是删至命令行首，但iterm中是删掉整行) C+w A+d 从光标处删至字首/尾 C+h C+d 删掉光标前后的自负 C+y 粘贴至光标后 C+r 搜索命令历史，这个较常用 选择喜欢的配色方案。 在Preferences-&gt;Profiles-&gt;Colors的load presets可以选择某个配色方案。也可以自己下载。在网站http://iterm2colorschemes.com/，几乎可以找到所有可用的配色方案。 选中即复制 iterm2有2种好用的选中即复制模式。 一种是用鼠标，在iterm2中，选中某个路径或者某个词汇，那么，iterm2就自动复制了。 另一种是无鼠标模式，⌘+f,弹出iterm2的查找模式，输入要查找并复制的内容的前几个字母，确认找到的是自己的内容之后，输入tab，查找窗口将自动变化内容，并将其复制。如果输入的是shift+tab，则自动将查找内容的左边选中并复制。 路径重复 在新Tab中自动使用前一Tab路径，如此设置： 屏幕切割 ⌘+d：垂直分割； ⌘+shift+d：水平分割 系统热键 设置好系统热线之后，将在正常的浏览器或者编辑器等窗口的上面，以半透明窗口形式直接调出iterm2 shell。 按下同样的系统热键之后，将自动隐藏。这样非常有利于随时随地处理。 自动完成 输入打头几个字母，然后输入⌘+; iterm2将自动列出之前输入过的类似命令。 剪切历史 输入⌘+shift+h，iterm2将自动列出剪切板的历史记录。如果需要将剪切板的历史记录保存到磁盘，在Preferences &gt; General &gt; Save copy/paste history to disk.中设置。 全屏切换 ⌘+enter进入与返回全屏模式 Exposé所有Tab ⌘+option+e,并且可以搜索 保存当前快照 Window &gt; Save Window Arrangement. 同样，恢复快照： Window &gt; Restore Window Arrangement 可以在Preferences &gt; General &gt; Open saved window arrangement.设置自动恢复快照","categories":[{"name":"mac快捷键","slug":"mac快捷键","permalink":"https://ymagic.github.io/categories/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"iTerm2","slug":"mac快捷键/iTerm2","permalink":"https://ymagic.github.io/categories/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/iTerm2/"}],"tags":[{"name":"mac快捷键","slug":"mac快捷键","permalink":"https://ymagic.github.io/tags/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"iTerm2","slug":"iTerm2","permalink":"https://ymagic.github.io/tags/iTerm2/"}]},{"title":"mac快捷键之idea篇","slug":"mac快捷键之idea篇","date":"2021-10-21T03:16:40.000Z","updated":"2022-08-25T06:35:49.064Z","comments":true,"path":"2021/10/21/mac-kuai-jie-jian-zhi-idea-pian/","link":"","permalink":"https://ymagic.github.io/2021/10/21/mac-kuai-jie-jian-zhi-idea-pian/","excerpt":"建议将 Mac 系统中与 IntelliJ IDEA 冲突的快捷键取消或更改，不建议改 IntelliJ IDEA 的默认快捷键。","text":"建议将 Mac 系统中与 IntelliJ IDEA 冲突的快捷键取消或更改，不建议改 IntelliJ IDEA 的默认快捷键。 Mac键盘符号和修饰键说明 ⌘ Command ⇧ Shift ⌥ Option ⌃ Control ↩︎ Return/Enter ⌫ Delete ⌦ 向前删除键（Fn+Delete） ↑ 上箭头 ↓ 下箭头 ← 左箭头 → 右箭头 ⇞ Page Up（Fn+↑） ⇟ Page Down（Fn+↓） Home （Fn + ←） End （Fn + →） ⇥ 右制表符（Tab键） ⇤ 左制表符（Shift+Tab） ⎋ Escape (Esc) 一、Editing（编辑） ⌃Space 基本的代码补全（补全任何类、方法、变量） ⌃⇧Space 智能代码补全（过滤器方法列表和变量的预期类型） ⌘⇧↩ 自动结束代码，行末自动添加分号 ⌘P 显示方法的参数信息 ⌃J, Mid. button click 快速查看文档 ⇧F1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档） ⌘+鼠标放在代码上 显示代码简要信息 ⌘F1 在错误或警告处显示具体描述信息 ⌘F12 查找类中方法 ⌘N, ⌃↩, ⌃N 生成代码（getter、setter、构造函数、hashCode/equals,toString） ⌃O 覆盖方法（重写父类方法） ⌃I 实现方法（实现接口中的方法） ⌘⌥T 包围代码（使用if…else, try…catch, for, synchronized等包围选中的代码） ⌘/ 注释/取消注释与行注释 ⌘⌥/ 注释/取消注释与块注释 ⌥↑ 连续选中代码块 ⌥↓ 减少当前选中的代码块 ⌃⇧Q 显示上下文信息 ⌥↩ 显示意向动作和快速修复代码 ⌘⌥L 格式化代码 ⌃⌥O 优化import ⌃⌥I 自动缩进线 ⇥ / ⇧⇥ 缩进代码 / 反缩进代码 ⌘X 剪切当前行或选定的块到剪贴板 ⌘C 复制当前行或选定的块到剪贴板 ⌘V 从剪贴板粘贴 ⌘⇧V 从最近的缓冲区粘贴 ⌘D 复制当前行或选定的块 ⌘⌫ 删除当前行或选定的块的行 ⌃⇧J 智能的将代码拼接成一行 ⌘↩ 智能的拆分拼接的行 ⇧↩ 开始新的一行 ⌘⇧U 大小写切换 ⌘⇧] / ⌘⇧[ 选择直到代码块结束/开始 ⌥⌦ 删除到单词的末尾（⌦键为Fn+Delete） ⌥⌫ 删除到单词的开头 ⌘+ / ⌘- 展开 / 折叠代码块 ⌘⇧+ 展开所以代码块 ⌘⇧- 折叠所有代码块 ⌘W 关闭活动的编辑器选项卡 二、Search/Replace（查询/替换） Double ⇧ 查询任何东西 ⌘F 文件内查找 ⌘G 查找模式下，向下查找 ⌘⇧G 查找模式下，向上查找 ⌘R 文件内替换 ⌘⇧F 全局查找（根据路径） ⌘⇧R 全局替换（根据路径） ⌘⇧S 查询结构（Ultimate Edition 版专用，需要在Keymap中设置） ⌘⇧M 替换结构（Ultimate Edition 版专用，需要在Keymap中设置） 三、Usage Search（使用查询） ⌥F7 / ⌘F7 在文件中查找用法 / 在类中查找用法 ⌘⇧F7 在文件中突出显示的用法 ⌘⌥F7 显示用法 ⌘⇧I 查看定义的类,快速查看 四、Compile and Run（编译和运行） ⌘F9 编译Project ⌘⇧F9 编译选择的文件、包或模块 ⌃⌥R 弹出 Run 的可选择菜单 ⌃⌥D 弹出 Debug 的可选择菜单 ⌃R 运行 ⌃D 调试 ⌃⇧R, ⌃⇧D 从编辑器运行上下文环境配置 五、Debugging（调试） F8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 F7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 ⇧F7 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法 ⇧F8 跳出 ⌥F9 运行到光标处，如果光标前有其他断点会进入到该断点 ⌥F8 计算表达式（可以更改变量值使其生效） ⌘⌥R 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上 ⌘F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点） ⌘⇧F8 查看断点信息 六、Navigation（导航） ⌘O 查找类文件 ⌘⇧O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/ ⌘⌥O 前往指定的变量 / 方法 ⌃← / ⌃→ 左右切换打开的编辑tab页 F12 返回到前一个工具窗口 ⎋ 从工具窗口进入代码文件窗口 ⇧⎋ 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口 ⌘⇧F4 关闭活动run/messages/find/… tab ⌘L 在当前文件跳转到某一行的指定处 ⌘E 显示最近打开的文件记录列表 ⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方 ⌘⇧⌫ 跳转到最后一个编辑的地方 ⌥F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder) ⌘B / ⌘ 鼠标点击 进入光标所在的方法/变量的接口或是定义处 ⌘⌥B 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 ⌥ Space, ⌘Y 快速打开光标所在方法、类的定义 ⌃⇧B 跳转到类型声明处 ⌘U 前往当前光标所在方法的父类的方法 / 接口定义 ⌃↓ / ⌃↑ 当前光标跳转到当前文件的前一个/后一个方法名位置 ⌘] / ⌘[ 移动光标到当前所在代码的花括号开始/结束位置 ⌘F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法） ⌃H 显示当前类的层次结构 ⌘⇧H 显示方法层次结构 ⌃⌥H 显示调用层次结构 F2 / ⇧F2 跳转到下一个/上一个突出错误或警告的位置 F4 / ⌘↓ 编辑/查看代码源 ⌥ Home 显示到当前文件的导航条 F3选中文件/文件夹/代码行，添加/取消书签 ⌥F3 选中文件/文件夹/代码行，使用助记符添加/取消书签 ⌃0…⌃9 定位到对应数值的书签位置 ⌘F3 显示所有书签 七、Refactoring（重构） F5 复制文件到指定目录 F6 移动文件到指定目录 ⌘⌫ 在文件上为安全删除文件，弹出确认框 ⇧F6 重命名文件 ⌘F6 更改签名 ⌘⌥N 一致性 ⌘⌥M 将选中的代码提取为方法 ⌘⌥V 提取变量 ⌘⌥F 提取字段 ⌘⌥C 提取常量 ⌘⌥P 提取参数 八、VCS/Local History（版本控制/本地历史记录） ⌘K 提交代码到版本控制器 ⌘T 从版本控制器更新代码 ⌥⇧C 查看最近的变更记录 ⌃C 快速弹出版本控制器操作面板 九、Live Templates（动态代码模板） ⌘⌥J 弹出模板选择窗口，将选定的代码使用动态模板包住 ⌘J 插入自定义动态代码模板 十、General（通用） ⌘1…⌘9 打开相应编号的工具窗口 ⌘S 保存所有 ⌘⌥Y 同步、刷新 ⌃⌘F 切换全屏模式 ⌘⇧F12 切换最大化编辑器 ⌥⇧F 添加到收藏夹 ⌥⇧I 检查当前文件与当前的配置文件 §⌃, ⌃` 快速切换当前的scheme（切换主题、代码样式等） ⌘, 打开IDEA系统设置 ⌘; 打开项目结构对话框 ⇧⌘A 查找动作（可设置相关选项） ⌃⇥ 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口） 十一、Other（一些官方文档上没有体现的快捷键） ⌘⇧8 竖编辑模式","categories":[{"name":"mac快捷键","slug":"mac快捷键","permalink":"https://ymagic.github.io/categories/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"idea","slug":"mac快捷键/idea","permalink":"https://ymagic.github.io/categories/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/idea/"}],"tags":[{"name":"mac快捷键","slug":"mac快捷键","permalink":"https://ymagic.github.io/tags/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"idea","slug":"idea","permalink":"https://ymagic.github.io/tags/idea/"}]},{"title":"mac快捷键之浏览器篇","slug":"mac快捷键之浏览器篇","date":"2021-10-21T03:05:24.000Z","updated":"2022-08-25T06:35:37.552Z","comments":true,"path":"2021/10/21/mac-kuai-jie-jian-zhi-liu-lan-qi-pian/","link":"","permalink":"https://ymagic.github.io/2021/10/21/mac-kuai-jie-jian-zhi-liu-lan-qi-pian/","excerpt":"","text":"1.标签（tab）操作： command+R（刷新页面，支持Safari和Chrome） command++/-/0（放大、缩小、还原，支持Safari和Chrome） command+T（新建标签页，支持Safari和Chrome）Command+N是新建单独窗口 command+L（定位到地址栏，支持Safari和Chrome） command+Y（打开历史访问，支持Safari和Chrome） command+Shift+N（新建隐私浏览窗口，支持Safari和Chrome） command+Option+U：显示源代码 command+Option+I：开发者工具 command+D：收藏 command+Shift+J：打开下载（Chrome） command+Z：恢复最近关闭的标签页 command+W：关闭当前标签页 command+.：停止刷新重载 2.书签（bookmarks）操作： control+command+1: 显示书签边栏 command+D：添加到收藏夹（书签栏） option+command+B：管理/编辑书签页","categories":[{"name":"mac快捷键","slug":"mac快捷键","permalink":"https://ymagic.github.io/categories/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"浏览器","slug":"mac快捷键/浏览器","permalink":"https://ymagic.github.io/categories/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"mac快捷键","slug":"mac快捷键","permalink":"https://ymagic.github.io/tags/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"}]},{"title":"Docker上安装nacos","slug":"Docker上安装nacos","date":"2021-05-13T05:58:03.000Z","updated":"2022-08-25T06:34:01.846Z","comments":true,"path":"2021/05/13/docker-shang-an-zhuang-nacos/","link":"","permalink":"https://ymagic.github.io/2021/05/13/docker-shang-an-zhuang-nacos/","excerpt":"","text":"Docker 上启动nacos-server 服务 拉取镜像 1docker pull nacos/nacos-server 挂载目录 123mkdir -p /home/nacos/logs/ #新建logs目录mkdir -p /home/nacos/init.d/ vim /home/nacos/init.d/custom.properties #修改配置文件 添加如下参数 12345678910111213141516171819202122232425262728293031323334server.contextPath=/nacosserver.servlet.contextPath=/nacosserver.port=8848spring.datasource.platform=mysqldb.num=1db.url.0=jdbc:mysql://xx.xx.xx.x:3306/nacos_devtest_prod?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.user=userdb.password=passnacos.cmdb.dumpTaskInterval=3600nacos.cmdb.eventTaskInterval=10nacos.cmdb.labelTaskInterval=300nacos.cmdb.loadDataAtStart=falsemanagement.metrics.export.elastic.enabled=falsemanagement.metrics.export.influx.enabled=falseserver.tomcat.accesslog.enabled=trueserver.tomcat.accesslog.pattern=%h %l %u %t &quot;%r&quot; %s %b %D %&#123;User-Agent&#125;inacos.security.ignore.urls=/,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/v1/auth/login,/v1/console/health/**,/v1/cs/**,/v1/ns/**,/v1/cmdb/**,/actuator/**,/v1/console/server/**nacos.naming.distro.taskDispatchThreadCount=1nacos.naming.distro.taskDispatchPeriod=200nacos.naming.distro.batchSyncKeyCount=1000nacos.naming.distro.initDataRatio=0.9nacos.naming.distro.syncRetryDelay=5000nacos.naming.data.warmup=truenacos.naming.expireInstance=true mysql5初始化数据库 脚本：https://github.com/alibaba/nacos/blob/master/config/src/main/resources/META-INF/nacos-db.sql 启动容器 123456789101112131415161718docker run \\--name nacos -d \\-p 8848:8848 \\--privileged=true \\--restart=always \\-e JVM_XMS=256m \\-e JVM_XMX=256m \\-e MODE=standalone \\-e PREFER_HOST_MODE=hostname \\-e SPRING_DATASOURCE_PLATFORM=mysql \\-e MYSQL_SERVICE_HOST=替换具体数据库实例 \\-e MYSQL_SERVICE_DB_NAME=数据库\\-e MYSQL_SERVICE_PORT=数据库端口\\-e MYSQL_SERVICE_USER=数据库用户名\\-e MYSQL_SERVICE_PASSWORD=数据库密码\\-v /home/nacos/logs:/home/nacos/logs \\-v /home/nacos/init.d/custom.properties:/home/nacos/init.d/custom.properties \\nacos/nacos-server","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://ymagic.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://ymagic.github.io/tags/SpringCloud/"},{"name":"nacos","slug":"nacos","permalink":"https://ymagic.github.io/tags/nacos/"}]},{"title":"Sql优化","slug":"Sql优化","date":"2020-10-02T02:11:31.000Z","updated":"2022-08-25T06:36:21.832Z","comments":true,"path":"2020/10/02/sql-you-hua/","link":"","permalink":"https://ymagic.github.io/2020/10/02/sql-you-hua/","excerpt":"","text":"sql优化 MySQL层优化我一般遵从五个原则： 减少数据访问： 设置合理的字段类型，启用压缩，通过索引访问等减少磁盘IO 返回更少的数据： 只返回需要的字段和数据分页处理 减少磁盘io及网络io 减少交互次数： 批量DML操作，函数存储等减少数据连接次数 减少服务器CPU开销： 尽量减少数据库排序操作以及全表查询，减少cpu 内存占用 利用更多资源： 使用表分区，可以增加并行操作，更大限度利用cpu资源 总结到SQL优化中，就三点: 最大化利用索引； 尽可能避免全表扫描； 减少无效数据的查询； SELECT语句 - 语法顺序： SELECT DISTINCT &lt;select_list&gt; FROM &lt;left_table&gt; &lt;join_type&gt; JOIN &lt;right_table&gt; ON &lt;join_condition&gt; WHERE &lt;where_condition&gt; GROUP BY &lt;group_by_list&gt; HAVING &lt;having_condition&gt; ORDER BY &lt;order_by_condition&gt; LIMIT &lt;limit_number&gt; SELECT语句 - 执行顺序： 123456789101112131415161718192021FROM&lt;表名&gt; # 选取表，将多个表数据通过笛卡尔积变成一个表。ON&lt;筛选条件&gt; # 对笛卡尔积的虚表进行筛选JOIN&lt;join, left join, right join...&gt;&lt;join表&gt; # 指定join，用于添加数据到on之后的虚表中，例如left join会将左表的剩余数据添加到虚表中WHERE&lt;where条件&gt; # 对上述虚表进行筛选GROUP BY&lt;分组条件&gt; # 分组&lt;SUM()等聚合函数&gt; # 用于having子句进行判断，在书写上这类聚合函数是写在having判断里面的HAVING&lt;分组筛选&gt; # 对分组后的结果进行聚合筛选SELECT&lt;返回数据列表&gt; # 返回的单列必须在group by子句中，聚合函数除外DISTINCT#数据除重ORDER BY&lt;排序条件&gt; # 排序LIMIT&lt;行数限制&gt; SQL优化策略 一. 避免不走索引的场景 二. SELECT语句其他优化 避免出现select *, 使用具体字段 避免出现不确定结果的函数 多表关联查询时，小表在前，大表在后 使用表的别名 用where字句替换HAVING字句 调整Where字句中的连接顺序 MySQL采用从左往右，自上而下的顺序解析where子句。根据这个原理，应将过滤数据多的条件往前放，最快速度缩小结果集 三、增删改 DML 语句优化 大批量插入数据 适当使用commit 适当使用commit可以释放事务占用的资源而减少消耗，commit后能释放的资源如下： 事务占用的undo数据块； 事务在redo log中记录的数据块； 释放事务施加的，减少锁争用影响性能。特别是在需要使用delete删除大量数据的时候，必须分解删除量并定期commit 避免重复查询更新的数据 四、查询条件优化 对于复杂的查询，可以使用中间临时表 暂存数据 优化group by语句 默认情况下，MySQL 会对GROUP BY分组的所有值进行排序,如果显式包括一个包含相同的列的 ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。 因此，如果查询包括 GROUP BY 但你并不想对分组的值进行排序，你可以指定 ORDER BY NULL禁止排序 优化join语句 MySQL中可以通过子查询来使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN)…替代。 例子：假设要将所有没有订单记录的用户取出来，可以用下面这个查询完成： SELECT col1 FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo ) 如果使用连接(JOIN)… 来完成这个查询工作，速度将会有所提升。尤其是当 salesinfo表中对 CustomerID 建有索引的话，性能将会更好，查询如下： SELECT col1 FROM customerinfo LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID WHERE salesinfo.CustomerID IS NULL 连接(JOIN)… 之所以更有效率一些，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。 优化union查询 MySQL通过创建并填充临时表的方式来执行union查询。除非确实要消除重复的行，否则建议使用union all。原因在于如果没有all这个关键词，MySQL会给临时表加上distinct选项，这会导致对整个临时表的数据做唯一性校验，这样做的消耗相当高。 高效： SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 UNION ALL SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= ‘TEST’; 低效： SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 UNION SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= ‘TEST’; 拆分复杂SQL为多个小SQL，避免大事务 使用truncate代替delete 使用合理的分页方式以提高分页效率","categories":[{"name":"sql优化","slug":"sql优化","permalink":"https://ymagic.github.io/categories/sql%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"sql优化","slug":"sql优化","permalink":"https://ymagic.github.io/tags/sql%E4%BC%98%E5%8C%96/"}]},{"title":"hexo搭建博客","slug":"hexo搭建博客","date":"2020-09-02T02:51:27.000Z","updated":"2022-08-25T06:49:16.940Z","comments":true,"path":"2020/09/02/hexo-da-jian-bo-ke/","link":"","permalink":"https://ymagic.github.io/2020/09/02/hexo-da-jian-bo-ke/","excerpt":"记录使用hexo搭建博客的过程。 环境macOS Big Sur 11.6.6","text":"记录使用hexo搭建博客的过程。 环境macOS Big Sur 11.6.6 安装node 在终端中执行 brew install node 即可安装 安装hexo 可参考官方文档 命令 pnpm install -g hexo-cli ​ 使用 hexo -v 可以查看 hexo 的版本和依赖的版本包 新建文件夹blog 在终端中进入到blog的文件夹的路径下，执行 hexo init 对blog文件夹进行初始化 hexo g 生成静态页面； hexo s 将网站运行起来 访问 http://localhost:4000，出现 Hexo 默认页面，本地博客安装成功！ 发布到远程仓库 需要安装插件hexo-deployer-git 1pnpm install hexo-deployer-git --save 修改hexo根目录下的_config.yml配置文件 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git仓库地址 branch: master 发布到远程仓库 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 博客优化 修改博客站点信息 修改hexo根目录下的_config.yml配置文件 12345678# Sitetitle: Daniel的博客 #网站标题subtitle: &#x27;&#x27; #网站副标题description: &#x27;随手记录自己的学习过程&#x27; #网站描述keywords:author: Daniel·young #作者language: zh-CN #博客的语言timezone: &#x27;Asia/Shanghai&#x27; #博客的时区 使用pure主题 pure主题地址:https://github.com/cofess/hexo-theme-pure.git 克隆pure主题到本地,终端切到博客的根目录下，执行以下命令 1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 修改hexo根目录下的_config.yml配置文件 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: pure 安装插件 在终端中执行以下命令 1234567pnpm install hexo-generator-json-content --savepnpm install hexo-generator-feed --save pnpm install hexo-generator-sitemap --savepnpm install hexo-generator-baidu-sitemap --save 文章浏览量统计、字数统计和阅读时长统计 安装hexo-wordcount插件 1pnpm install hexo-wordcount --save #字数统计插件 修改pure/_config.yml配置文件 12345678910# PVpv: busuanzi: enable: true # 不蒜子统计 # wordcountpostCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计 配置打赏信息 修改pure/_config.yml配置文件 1234567891011# Donatedonate: enable: true # 微信打赏 wechatpay: qrcode: images/donate/wechatpayimg.jpg #在主题目录的source文件夹中进行图片设定 title: 微信支付 # 支付宝打赏 alipay: qrcode: images/donate/alipayimg.jpg #在主题目录的source文件夹中进行图片设定 title: 支付宝 开启评论功能 修改pure/_config.yml配置文件 12comment: type: valine # 启用哪种评论系统 Valine一个无后端的评论框工具，其依赖于 Leancloud 开发，所以使用前需要先注册 Leancloud 账号 123456789101112valine: # Valine官方地址. https://valine.js.org appid: # 你的leancloud应用appid appkey: # 你的leancloud应用appkey notify: false #是否开启评论邮件提醒 , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style meta: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: ture # Article reading statistic https://valine.js.org/visitor.html highlight: ture recordIp: ture 开启搜索功能 修改pure/_config.yml配置文件 1234# Searchsearch: insight: true #内置搜索功能 baidu: false #百度搜索功能，不可以同时使用 文章链接转静态短地址 如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO,可以用hexo-permalink-pinyin插件使在生成文章时生成中文拼音的永久链接 1pnpm install hexo-permalink-pinyin --save hexo根目录下的_config.yml配置文件中，新增以下配置项 123permalink_pinyin: enable: ture separator: &#x27;-&#x27; 页面静态资源压缩 为提高页面渲染速度，需要对页面的静态资源进行压缩，包括 css、js 和 html 等文件。 可以使用 hexo-neat 插件进行压缩。hexo-neat 配置简单，无需额外命令，我们只需使用原本的调试、部署命令就可以自动完成静态资源的压缩。 安装hexo-neat插件 1pnpm install hexo-neat --save 在站点配置文件_config.yml 中添加以下代码： 12345678910111213141516# hexo-neatneat_enable: trueneat_html: enable: true exclude: neat_css: enable: true exclude: - &#x27;*.min.css&#x27;neat_js: enable: true mangle: true output: compress: exclude: - &#x27;*.min.js&#x27; 数学公式 需要先更换markdown的渲染器 删除原来的渲染器 1pnpm un hexo-renderer-marked --save 下载新渲染器 1pnpm install @upupming/hexo-renderer-markdown-it-plus --save 在站点配置文件_config.yml 中添加以下代码： 123456789101112131415161718#hexo-renderer-markdown-it-plus#hexo-renderer-markdown-it-plusmarkdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ plugins: - markdown-it-katex #支持katex公式 - markdown-it-mark #支持==marked== →inserted - markdown-it-ins #支持++Inserted++ 下划线， ~~Del~~ 删除线 - markdown-it-sub #支持H~2~O →H2O下标 - markdown-it-sup #支持X^2^ →X2上标 - markdown-it-footnote #支持引入参考文献。emmm就是上标数字，最后附上文献那种 a+b+c⏞notea+b+c⏟noteπ=cd\\overbrace{a+b+c}^{\\text{note}} \\underbrace{a+b+c}_{\\text{note}} \\boxed{\\pi=\\frac c d} a+b+c​note​notea+b+c​​π=dc​​ markdown-it-mark #支持==marked== → marked markdown-it-ins #支持++Inserted++ → Inserted， ~~Del~~ → Del markdown-it-sub #支持H~2~O → H2O markdown-it-sup #支持X^23^ → X23 markdown-it-footnote #支持引入参考文献。就是上标数字，最后附上文献那种","categories":[{"name":"hexo","slug":"hexo","permalink":"https://ymagic.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ymagic.github.io/tags/hexo/"}]},{"title":"流量控制策略之限流","slug":"流量控制策略之限流","date":"2019-12-02T07:45:03.000Z","updated":"2022-08-25T06:33:22.646Z","comments":true,"path":"2019/12/02/liu-liang-kong-zhi-ce-lue-zhi-xian-liu/","link":"","permalink":"https://ymagic.github.io/2019/12/02/liu-liang-kong-zhi-ce-lue-zhi-xian-liu/","excerpt":"场景描述 由于业务应用系统的负载能力有限，为了防止非预期的请求对系统压力过大而拖垮业务应用系统 也就是面对大流量时，如何进行流量控制？","text":"场景描述 由于业务应用系统的负载能力有限，为了防止非预期的请求对系统压力过大而拖垮业务应用系统 也就是面对大流量时，如何进行流量控制？ 在开发高并发系统时可以采用三种方式用于保护系统：缓存、降级和限流 缓存：缓存的目的是提升系统访问速度和增大系统处理容量 降级：降级是当服务出现问题或者影响到核心流程时，需要暂时屏蔽掉，待高峰或者问题解决后再打开 限流：限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理 缓存的目的是提升系统访问速度和增大系统能处理的容量，可谓是抗高并发流量的银弹；而降级是当服务出问题或者影响到核心流程的性能则需要暂时屏蔽掉，待高峰或者问题解决后再打开；而有些场景并不能用缓存和降级来解决，比如稀缺资源（秒杀、抢购）、写服务（如评论、下单）、频繁的复杂查询（评论的最后几页），因此需有一种手段来限制这些场景的并发/请求量，即限流。 系统在设计之初就会有一个预估容量，长时间超过系统能承受的TPS/QPS阈值，系统可能会被压垮，最终导致整个服务不够用。为了避免这种情况，我们就需要对接口请求进行限流。 限流的目的是通过对并发访问请求进行限速或者一个时间窗口内的的请求数量进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待。 一般开发高并发系统常见的限流模式有控制并发和控制速率，一个是限制并发的总数量（比如数据库连接池、线程池），一个是限制并发访问的速率（如nginx的limit_conn模块，用来限制瞬时并发连接数），另外还可以限制单位时间窗口内的请求数量（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率）。其他还有如限制远程接口调用速率、限制MQ的消费速率。另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。 本文主要介绍应用级限流方法 应用级限流 控制并发数量 属于一种较常见的限流手段，在实际应用中可以通过信号量机制（如Java中的Semaphore）来实现。 操作系统的信号量是个很重要的概念，Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。 12345678910111213141516public class DubboService &#123; private final Semaphore permit = new Semaphore(10, true); public void process()&#123; try&#123; permit.acquire(); //业务逻辑处理 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; permit.release(); &#125; &#125;&#125; 在以上代码中，虽然有30个线程在执行，但是只允许10个并发的执行。Semaphore的构造方法Semaphore(int permits) 接受一个整型的数字，表示可用的许可证数量。Semaphore(10)表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()获取一个许可证，使用完之后调用release()归还许可证，还可以用tryAcquire()方法尝试获取许可证，信号量的本质是控制某个资源可被同时访问的个数，在一定程度上可以控制某资源的访问频率，但不能精确控制，控制访问频率的模式见下文描述。 控制访问频率 常见的限流算法有：计数器、漏桶、令牌桶。 计数器 采用计数器实现限流有点简单粗暴，一般我们会限制一秒钟的能够通过的请求数，比如限流qps为100，算法的实现思路就是从第一个请求进来开始计时，在接下去的1s内，每来一个请求，就把计数加1，如果累加的数字达到了100，那么后续的请求就会被全部拒绝。等到1s结束后，把计数恢复成0，重新开始计数。 具体的实现可以是这样的：对于每次服务调用，可以通过 AtomicLong#incrementAndGet()方法来给计数器加1并返回最新值，通过这个最新值和阈值进行比较。 这种实现方式，相信大家都知道有一个弊端：如果我在单位时间1s内的前10ms，已经通过了100个请求，那后面的990ms，只能眼巴巴的把请求拒绝，我们把这种现象称为“突刺现象” 漏桶算法 漏桶算法的思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水（接口有响应速率），当水流入速度过大会直接溢出（访问频率超过接口响应速率），可以看出漏桶算法能强行限制数据的传输速率。 可见这里有两个变量,一个是桶的大小,支持流量突发增多时可以存多少的水(burst),另一个是水桶漏洞的大小(rate)。 因为漏桶的漏出速率是固定的参数,所以,即使网络中不存在资源冲突(没有发生拥塞),漏桶算法也不能使流突发(burst)到端口速率.因此,漏桶算法对于存在突发特性的流量来说缺乏效率. 令牌桶算法 令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务，令牌桶算法通过发放令牌，根据令牌的rate频率做请求频率限制，容量限制等。 令牌桶算法 每过1/r秒桶中增加一个令牌。 桶中最多存放b个令牌，如果桶满了，新放入的令牌会被丢弃。 当一个n字节的数据包到达时，消耗n个令牌，然后发送该数据包。 如果桶中可用令牌小于n，则该数据包将被缓存或丢弃。 令牌桶控制的是一个时间窗口内通过的数据量，在API层面我们常说的QPS、TPS，正好是一个时间窗口内的请求量或者事务量，只不过时间窗口限定在1s罢了。以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。令牌桶的另外一个好处是可以方便的改变速度，一旦需要提高速率，则按需提高放入桶中的令牌的速率。 通常使用Google开源工具包Guava提供的限流工具类RateLimiter来实现控制速率，该类基于令牌桶算法来完成限流，非常易于使用，而且非常高效。如我们不希望每秒的任务提交超过1个 1234567891011public static void main(String[] args) &#123; String start = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date()); RateLimiter limiter = RateLimiter.create(1.0); // 这里的1表示每秒允许处理的量为1个 for (int i = 1; i &lt;= 10; i++) &#123; double waitTime = limiter.acquire(i);// 请求RateLimiter, 超过permits会被阻塞 System.out.println(&quot;cutTime=&quot; + System.currentTimeMillis() + &quot; call execute:&quot; + i + &quot; waitTime:&quot; + waitTime); &#125; String end = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date()); System.out.println(&quot;start time:&quot; + start); System.out.println(&quot;end time:&quot; + end); &#125; 首先通过RateLimiter.create(1.0);创建一个限流器，参数代表每秒生成的令牌数，通过limiter.acquire(i);来以阻塞的方式获取令牌，令牌桶算法允许一定程度的突发（允许消费未来的令牌），所以可以一次性消费i个令牌；当然也可以通过tryAcquire(int permits, long timeout, TimeUnit unit)来设置等待超时时间的方式获取令牌，如果超timeout为0，则代表非阻塞，获取不到立即返回，支持阻塞或可超时的令牌消费。 从输出来看，RateLimiter支持预消费，比如在acquire(5)时，等待时间是4秒，是上一个获取令牌时预消费了3个令牌，固需要等待3*1秒，然后又预消费了5个令牌，以此类推。 滑动窗口","categories":[{"name":"流量控制","slug":"流量控制","permalink":"https://ymagic.github.io/categories/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"},{"name":"限流","slug":"流量控制/限流","permalink":"https://ymagic.github.io/categories/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/%E9%99%90%E6%B5%81/"}],"tags":[{"name":"流量控制","slug":"流量控制","permalink":"https://ymagic.github.io/tags/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"},{"name":"限流","slug":"限流","permalink":"https://ymagic.github.io/tags/%E9%99%90%E6%B5%81/"}]},{"title":"Redis","slug":"Redis","date":"2019-10-02T02:11:31.000Z","updated":"2022-08-25T06:36:07.161Z","comments":true,"path":"2019/10/02/redis/","link":"","permalink":"https://ymagic.github.io/2019/10/02/redis/","excerpt":"","text":"Redis 特点 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis 优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Redis value的数据结构 String、Hash、List、Set、ZSet String(字符串) 存储最简单的key-value结构 value可以是字符串、整数或者浮点型 可以对整个字符串或者字符串的一部分执行操作 对整数和浮点数执行自增或自减操作 使用场景 常规key-value缓存应用 分布式id生成器 list(列表) 一个链表，链表上的每各节点都包含了一个字符串，字符串可以重复 可以从链表的两端推入或者拉出元素 根据偏移量对链表进行修剪 读取单个或者多个元素 根据值查找或者移除元素 使用场景 最新消息排行等功能 消息队列 关注列表，粉丝列表 set(集合) 包含字符串的无序收集器，并且被包含的每个字符串都是独一无二，各不相同的，即不能重复 可以添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素 使用场景 共同好友，共同喜好，二度好友 统计网站访问IP（利用唯一性，统计访问网站的所有独立IP） 好友推荐（好友推荐时，根据tag求交集，大于某个阈值就可以推荐） hash(散列) 是一个string类型的field和value的映射表 包含键值对的无序散列表，键不能重复 可以添加、获取、移除单个键值对 获取所有键值对 使用场景 hash特别适合用于存储对象 存储用户信息（能单独修改用户某一属性信息） zset(有序集合) 有序集合的键被称为成员，每个成员都是各不相同的 而有序集合的值被称为分值，分值必须为浮点数 有序集合是字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小决定 可以添加、获取、删除单个元素 根据分值范围或者成员来获取元素 有序集合是redis里面唯一一个既可以根据成员访问元素（这一点和散列一样），又可以根据分值以及分值的排列顺序来访问元素的结构 使用场景 排行榜 带权重的消息队列 Redis keys命令 1234567891011121314151617181920212223242526272829303132333435del (key) 用于在key存在是删除keydump (key) 序列化给定的key,并返回被序列化的值exists (key) 检查给定的key是否存在expire (key seconds) 为给定key设置过期时间expire (key timestamp) EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)pexpire (key milliseconds) 设置 key 的过期时间以毫秒计pexpiret (key milliseconds-timestamp) 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计keys (pattern) 查找所有符合给定模式( pattern)的 keymove (key dbindex) 将当前数据库的 key 移动到有dbindex索引的数据库persist (key) 移除 key 的过期时间，key 将持久保持pttl (key) 以毫秒为单位返回 key 的剩余的过期时间。ttl (key) 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)rename (key newkey) 修改 key 的名称renamenx (key newkey) 仅当 newkey 不存在时，将 key 改名为 newkey type (key) 返回key所储存的值的类型dbsize 返回当前数据库中的key的数目flushdb 删除当前选择数据库中所有keyflushall 删除所有数据库中的所有key String 操作命令 1234567891011121314151617181920212223242526272829303132set (key value) 设置给定key的value值get (key) 获取指定key的值setnx (key value) 只有在key不存在时设置key的值mset (key1 value1 key2 value2 ... keyn valuen) 同时设置一个或多个key-value值msetnx (key1 value1 key2 value2 ... keyn valuen) 所有给定 key 都不存在时，同时设置一个或多个 key-value 对setex (key timeout value) 给指定的key设置值及过期时间,单位：秒psetex (key milliseconds value) 给指定的key设置值及过期时间,单位：毫秒getrange (key start end) 获取存储在指定key中字符串的子字符串，字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)incr (key) 将key中存储的数字值增一，如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 incr 操作，如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误，本操作的值限制在 64 位(bit)有符号数字表示之内decr (key) 将key中存储的数字值减一，如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 decr 操作，如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误，本操作的值限制在 64 位(bit)有符号数字表示之内incrby (key incr_amount) 将 key 中储存的数字加上指定的增量值,如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 incrby 命令,如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误,本操作的值限制在 64 位(bit)有符号数字表示之内decrby (key decr_amount) 将 key 所储存的值减去指定的减量值,如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 decrby 操作,如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误,本操作的值限制在 64 位(bit)有符号数字表示之内incrbyfloat (key incr_amount) 为 key 中所储存的值加上指定的浮点数增量值,如果 key 不存在，那么 INCRBYFLOAT 会先将 key 的值设为 0 ，再执行加法操作strlen (key) 获取key所存储字符串值的长度，当 key 储存的不是字符串值时，返回一个错误setrange (key offset value) 用指定的字符串覆盖给定 key 所储存的字符串值，覆盖的位置从偏移量 offset 开始append (key value) 为指定的 key 追加值,如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样 list 操作命令 1234567891011121314151617181920212223242526272829303132rpush (key value1 ... valuen) 用于将一个或多个值插入到列表的尾部(最右边)lindex 通过索引获取列表中的元素，也可以使用负数下标，以 -1 表示列表的最后一个元素，-2 表示列表的倒数第二个元素，以此类推lrange (key start end) 返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推rpoplpush (source_key destination_key) 移除列表的最后一个元素，并将该元素添加到另一个列表并返回blpop (list1 list2 ... listn timeout) 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止brpop (list1 list2 ... listn timeout) 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止brpoplpush (list another_list timeout) 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止lrem (key count value) 根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素。COUNT 的值可以是以下几种：count &gt; 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT ,count &lt; 0 : 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为 COUNT 的绝对值, count = 0 : 移除表中所有与 VALUE 相等的值llen (key) 用于返回列表的长度。 如果列表 key 不存在，则 key 被解释为一个空列表，返回 0 ,如果 key 不是列表类型，返回一个错误ltrim (key start stop) 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。下标 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推lpop (key) 用于移除并返回列表的第一个元素rpop (key) 用于移除并返回列表的最后一个元素lpushx (key value1 value2 ... valuen) 将一个或多个值插入到已存在的列表头部，列表不存在时操作无效rpushx (key value1 value2 ... valuen) 将一个或多个值插入到已存在的列表尾部(最右边)，列表不存在时操作无效linsert (key before|after ecisting_value new_value) 用于在列表的元素前或者后插入元素。当指定元素不存在于列表中时，不执行任何操作。当列表不存在时，被视为空列表，不执行任何操作。如果 key 不是列表类型，返回一个错误lset (key index value) 通过索引来设置元素的值,当索引参数超出范围，或对一个空列表进行 lset 时，返回一个错误 hash 操作命令 12345678910111213141516171819202122232425hset (key field value) 为哈希表中的字段赋值，如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作，如果字段已经存在于哈希表中，旧值将被覆盖hsetnx (key field value) 为哈希表中不存在的的字段赋值 。如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。如果字段已经存在于哈希表中，操作无效。如果 key 不存在，一个新哈希表被创建并执行 HSETNX 命令hget (key field_name) 用于返回哈希表中指定字段的值hgetall (key) 返回哈希表中所有的字段和值，返回值中紧跟每个字段名(field name)之后是字段的值(value)，所以返回值的长度是哈希表大小的两倍hmset (key field1 value1 filed2 value2 ... filedn valuen) 同时将多个field-value(字段-值)对设置到哈希表中，此命令会覆盖哈希表中已存在的字段，如果哈希表不存在，会创建一个空哈希表，并执行 HMSET 操作hmget (key field1 field2 ... fieldn) 用于返回哈希表中一个或多个给定字段的值，如果不存在，返回nil值hexists (key field) 查询hash表中指定字段是否存在hincrby (key field incr_by_number) 用于为哈希表中的字段值加上指定增量值。增量也可以为负数，相当于对指定字段进行减法操作。如果哈希表的 key 不存在，一个新的哈希表被创建并执行 hincrby 命令。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 。对一个储存字符串值的字段执行 HINCRBY 命令将造成一个错误hincrbyfloat (key field incr_by_number) 用于为哈希表中的字段值加上指定浮点数增量值.如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 hlen (key) 获取哈希表中字段的数量hdel (key field1 field2 ... fieldn) 用于删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略hvals (key) 返回哈希表所有字段的值hkeys (key) 获取哈希表中的所有字段名 set 操作命令 12345678910111213141516171819202122232425sscan (key [match pattern] [count countnum]) 迭代集合键中的元素sadd (key value1 ... valuen) 将一个或多个元素加入到集合srem (key value1 ... valuen) 移除集合中的一个或多个成员元素，不存在的成员元素会被忽略smembers (key) 返回集合中的所有成员，不存在的集合可以视为空集合scard (key) 返回集合中的元素数量sismember (key value) 判断成员是否是集合成员sunion (key1 key2 ... keyn) 返回指定集合的并集sunionstore (destination_key key1 key2 ... keyn) 将给定集合的并集存储在指定的集合 destination 中sinter (key1 key2 ... keyn) 返回给定所有集合的交集，不存在的集合 key 被视为空集sinterstore (destination_key key1 key2 ... keyn) 将给定集合之间的交集存储在指定的集合中。如果指定的集合已经存在，则将其覆盖sdiff (key1 key2 ... keyn) 返回给定集合之间的差集sdiffstore (destination_key key1 key2 ... keyn) 将给定集合之间的差集存储在指定的集合中。如果指定的集合 key 已存在，则会被覆盖spop (key) 用于移除并返回集合中的一个随机元素 sorted set 操作命令 1234567891011121314151617181920zcard (key) 计算集合中元素的数量zrange (key start stop [withscores]) 返回有序集合中指定区域内的成员，按成员分数值递增排序，下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推，你也可以使用负数下标，以 -1 表示最后一个成员zrevrange (key start stop [withscores]) 返回有序集合中指定区域内的成员，按成员分数值递减排序，下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推，你也可以使用负数下标，以 -1 表示最后一个成员zadd (key score1 value1 score2 value2 ... scoren valuen) 将一个或多个成员元素及其分数值加入到有序集当中,分数值可以是整数值或双精度浮点数acount (key min max) 计算有序集合中指定分数区间的成员数量zscore (key member) 返回有序集中，成员的分数值zincrby (key increment member) 对有序集合中指定成员的分数加上增量 increment,分数值可以是整数值或双精度浮点数,可正可负zrem (key member1 ... membern) 移除有序集中的一个或多个成员，不存在的成员将被忽略zrangebyscore (key min max [withscores] [limit offset count]) 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列,默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于) 例：zrangebyscore zset (1 5 1&lt;score&lt;=5 zrangebyscore zset -inf +inf 显示整个有序集zremrangebyscore (key min max) 移除有序集中，指定分数（score）区间内的所有成员 1redis-benchmark -n 100000 -q 同时执行10万个请求测试性能 持久化 RDB RDB是Redis用来进行持久化的一种方式，是把当前内存中的数据集快照写入磁盘，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里 触发方式：自动触发和手动触发 自动触发：在 redis.conf 配置文件中的 SNAPSHOTTING 下 save：这里是用来配置触发 Redis的持久化条件，也就是什么时候将内存中的数据保存到硬盘。默认如下配置： 123save 900 1：表示900 秒内如果至少有 1 个 key 的值变化，则保存save 300 10：表示300 秒内如果至少有 10 个 key 的值变化，则保存save 60 10000：表示60 秒内如果至少有 10000 个 key 的值变化，则保存 当然如果你只是用Redis的缓存功能，不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。可以直接一个空字符串来实现停用：save “” 1redis-cli config set save &quot; &quot; stop-writes-on-bgsave-error ：默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了 rdbcompression ；默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。 rdbchecksum ：默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能 dbfilename ：设置快照的文件名，默认是 dump.rdb dir：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。使用上面的 dbfilename 作为保存的文件名 也就是说通过在配置文件中配置的 save 方式，当实际操作满足该配置形式时就会进行 RDB 持久化，将当前的内存快照保存在 dir 配置的目录中，文件名由配置的 dbfilename 决定 恢复数据 将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可，redis就会自动加载文件数据至内存了。Redis 服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止 RDBDE的优势和劣势 优势： RDB是一个非常紧凑(compact)的文件，它保存了redis 在某个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复。 生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。 RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。 劣势： RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作(内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑)，频繁执行成本过高(影响性能) RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题(版本不兼容) 在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改(数据有丢失) AOF AOF是通过保存Redis服务器所执行的写命令来记录数据库状态 AOF配置 在 redis.conf 配置文件的 APPEND ONLY MODE 下： appendonly：默认值为no，也就是说redis 默认使用的是rdb方式持久化，如果想要开启 AOF 持久化方式，需要将 appendonly 修改为 yes。 appendfilename ：aof文件名，默认是&quot;appendonly.aof&quot; appendfsync：aof持久化策略的配置； no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快，但是不太安全； always表示每次写入都执行fsync，以保证数据同步到磁盘，效率很低； everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。通常选择 everysec ，兼顾安全性和效率。 no-appendfsync-on-rewrite：在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。 设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。默认值为no。 auto-aof-rewrite-percentage：默认值为100。aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。 auto-aof-rewrite-min-size：64mb。设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写。 aof-load-truncated：aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项，出现这种现象 redis宕机或者异常终止不会造成尾部不完整现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。默认值为 yes。 开启AOF 将 redis.conf 的 appendonly 配置改为 yes 即可。 AOF 保存文件的位置和 RDB 保存文件的位置一样，都是通过 redis.conf 配置文件的 dir 配置,可以通过 config get dir 命令获取保存的路径 AOF文件恢复 重启 Redis 之后就会进行 AOF 文件的载入。 异常修复命令：redis-check-aof --fix 进行修复 AOF重写 由于AOF持久化是Redis不断将写命令记录到 AOF 文件中，随着Redis不断的进行，AOF 的文件会越来越大，文件越大，占用服务器内存越大以及 AOF 恢复要求时间越长。为了解决这个问题，Redis新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令 bgrewriteaof 来重写 AOF 文件重写并不是对原文件进行重新整理，而是直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的 AOF 文件 AOF 文件重写触发机制：通过 redis.conf 配置文件中的 auto-aof-rewrite-percentage：默认值为100，以及auto-aof-rewrite-min-size：64mb 配置，也就是说默认Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。 这里再提一下，我们知道 Redis 是单线程工作，如果 重写 AOF 需要比较长的时间，那么在重写 AOF 期间，Redis将长时间无法处理其他的命令，这显然是不能忍受的。Redis为了克服这个问题，解决办法是将 AOF 重写程序放到子程序中进行，这样有两个好处： 1.子进程进行 AOF 重写期间，服务器进程（父进程）可以继续处理其他命令。 2.子进程带有父进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性 使用子进程解决了上面的问题，但是新问题也产生了：因为子进程在进行 AOF 重写期间，服务器进程依然在处理其它命令，这新的命令有可能也对数据库进行了修改操作，使得当前数据库状态和重写后的 AOF 文件状态不一致。 为了解决这个数据状态不一致的问题，Redis 服务器设置了一个 AOF 重写缓冲区，这个缓冲区是在创建子进程后开始使用，当Redis服务器执行一个写命令之后，就会将这个写命令也发送到 AOF 重写缓冲区。当子进程完成 AOF 重写之后，就会给父进程发送一个信号，父进程接收此信号后，就会调用函数将 AOF 重写缓冲区的内容都写到新的 AOF 文件中。 这样将 AOF 重写对服务器造成的影响降到了最低 AOF优缺点 优点： AOF 持久化的方法提供了多种的同步频率，即使使用默认的同步频率每秒同步一次，Redis 最多也就丢失 1 秒的数据而已。 AOF 文件使用 Redis 命令追加的形式来构造，因此，即使 Redis 只能向 AOF 文件写入命令的片断，使用 redis-check-aof 工具也很容易修正 AOF 文件。 AOF 文件的格式可读性较强，这也为使用者提供了更灵活的处理方式。例如，如果我们不小心错用了 FLUSHALL 命令，在重写还没进行时，我们可以手工将最后的 FLUSHALL 命令去掉，然后再使用 AOF 来恢复数据。 缺点： 对于具有相同数据的的 Redis，AOF 文件通常会比 RDF 文件体积更大。 虽然 AOF 提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能。但在 Redis 的负载较高时，RDB 比 AOF 具好更好的性能保证。 RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 方式更健壮。官方文档也指出，AOF 的确也存在一些 BUG，这些 BUG 在 RDB 没有存在。 Redis集群 集群命令 1redis-cli -a 123456 --cluster create 172.17.114.46:6000 172.17.114.46:6001 172.17.114.46:6002 172.17.114.46:6003 172.17.114.46:6004 172.17.114.46:6005 --cluster-replicas 1","categories":[{"name":"Redis","slug":"Redis","permalink":"https://ymagic.github.io/categories/Redis/"},{"name":"缓存","slug":"Redis/缓存","permalink":"https://ymagic.github.io/categories/Redis/%E7%BC%93%E5%AD%98/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://ymagic.github.io/tags/Redis/"}]},{"title":"Lambda表达式","slug":"Lambda表达式","date":"2018-12-09T08:08:42.000Z","updated":"2022-08-25T06:35:06.248Z","comments":true,"path":"2018/12/09/lambda-biao-da-shi/","link":"","permalink":"https://ymagic.github.io/2018/12/09/lambda-biao-da-shi/","excerpt":"Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。 使用 Lambda 表达式可以使代码变的更加简洁紧凑。","text":"Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。 使用 Lambda 表达式可以使代码变的更加简洁紧凑。 Lambda表达式的重要特征: 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。 可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。 可选的大括号：如果主体包含了一个语句，就不需要使用大括号。 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。 Lambda表达式有3个部分 一个代码块 参数 自由变量的值，这是指非参数而且不在代码中定义的变量 示例： 1234567891011121314151617181920212223242526interface MathOperation&#123; int operation(int a, int b);&#125;public class LambdaTest &#123; public static void main(String[] args) &#123; //类型声明 MathOperation add = (int a, int b) -&gt; a + b; //不声明类型 MathOperation sub = (a, b) -&gt; a - b; //带有大括号，带有返回语句 MathOperation mul = (int a, int b) -&gt; &#123;return a*b; &#125;; //不带大括号及返回语句 MathOperation div = (int a, int b) -&gt; a / b; System.out.println(&quot;10 + 5 = &quot;+ operator(10, 5, add)); System.out.println(&quot;10 - 5 = &quot;+ operator(10, 5, sub)); System.out.println(&quot;10 * 5 = &quot;+ operator(10, 5, mul)); System.out.println(&quot;10 / 5 = &quot;+ operator(10, 5, div)); &#125; private static int operator(int a, int b, MathOperation mathOperation) &#123; return mathOperation.operation(a, b); &#125;&#125; lambda表达式可以使用外围作用域中的变量（即自由变量），但只能引用值不会改变的变量，必须实际上是final变量（不可被后面的代码更改，也为隐性final）。 使用lambda表达式的重点是延时执行。毕竟，如果想要你寄执行代码，完全可以直接执行。希望以后再执行代码的原因有很多，如： 在一个单独的线程中运行代码； 多次运行代码； 在算法适当的位置运行代码(例如，排序中的比较操作)； 发生某种情况时执行代码(如，点击了一个按钮，数据到达，等等)； 只在必要时才运行代码。 函数式接口 对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式，这种接口称为函数式接口(functional inaterface) Arrays.sort方法，它的第二个参数需要一个Comparator实例，Comparator就是只有一个方法的接口，所以可以提供一个lambda表达式： 12345String[] words = &#123;&quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;, &quot;Mars&quot;, &quot;Jupiter&quot;, &quot;Saturn&quot;&#125;;Arrays.sort(words, (first, second) -&gt; first.length() - second.length());for (String word : words) &#123; System.out.println(word);&#125; 可以用@FunctionalInterface注解来标记自己设计的函数式接口 常用函数式接口 函数式接口 参数类型 返回类型 抽象方法名 描述 其他方法 Runnable 无 void run 作为无参或返回值的动作运行 Supplier&lt;T&gt; 无 void get 提供一个T类型的值 Consumer&lt;T&gt; T void accept 处理一个T类型的值 andThen BiConsumer&lt;T,U&gt; T, U void accept 处理T和U类型的值 andThen Function&lt;T,R&gt; T R apply 有一个T类型参数的函数 compose, andThen, identity BiFunction&lt;T,U,R&gt; T, U R apply 有T和U类型参数的函数 andThen UnaryOperator&lt;T&gt; T T apply 类型T上的一元操作符 compose, andThen, identity BinaryOperator&lt;T&gt; T, T T apply 类型T上的二元操作符 andThen, maxBy, identity Predicate&lt;T&gt; T boolean test 布尔值函数 and, or, negate, isEqual BiPredicate&lt;T,U&gt; T,U boolean test 有两个参数的布尔值函数 and, or, negate 基本类型的函数式接口 函数式接口 参数类型 返回类型 抽象方法名 BooleanSupplier none boolean getAsBoolean PSupplier none p getAsP PConsumer p void accept ObjPconsumer&lt;T&gt; T, p void accept PFunction&lt;T&gt; p T apply PToQFunction p q applyAsQ ToPFunction&lt;T&gt; T p applyAsP ToPBiFunction&lt;T, U&gt; T, U p applyAsP PUnaryOperator p p applyAsP PBinaryOperator p, p p applyAsP PPredicate p boolean test 注：p, q 为int, long, double; P, Q 为Int, Long, Double","categories":[{"name":"java 8","slug":"java-8","permalink":"https://ymagic.github.io/categories/java-8/"}],"tags":[{"name":"java8","slug":"java8","permalink":"https://ymagic.github.io/tags/java8/"},{"name":"Lambda","slug":"Lambda","permalink":"https://ymagic.github.io/tags/Lambda/"}]},{"title":"Java知识点","slug":"Java知识点","date":"2018-12-08T15:45:03.000Z","updated":"2022-08-25T06:34:43.545Z","comments":true,"path":"2018/12/08/java-zhi-shi-dian/","link":"","permalink":"https://ymagic.github.io/2018/12/08/java-zhi-shi-dian/","excerpt":"","text":"hashmap和treemap什么区别?低层数据结构是什么? ThreadPool用过吗？都有什么参数?底层如何实现的? sychnized和Lock什么区别?sychnized 什么情况情况是对象锁? 什么时候是全局锁为什么? ThreadLocal 是什么底层如何实现?写一个例子呗? volitile的工作原理? cas知道吗如何实现的? 讲讲单例模式的几种实现? 如何定位问题?如何解决思路和处理方法 知道字节码吗?字节码都有哪些?Integer x =5,int y =5，比较x =y 都经过哪些步骤? 讲讲类加载机制呗都有哪些类加载器，这些类加载器都加载哪些文件? 手写一下类加载Demo 从写equals为什么一定要重写hashcode？hashcode相等两个类一定相等吗? 介绍一Java当中常用的下集合类 hashmap hastable 实现什么不同?concurrenthashtable的原理? osgi是什么？如果实现的？ JVM的优化有哪些？都能达到什么效果 classforName(“java.lang.String”)和String classgetClassLoader() LoadClass(“java.lang.String”) 什么区别啊? 说说MySQL索引B+Tree机制 SQL执行计划详解？ 索引优化的手段你平常用过哪些？ 讲几个常用的sql优化手段 说一下dubbo的实现过程注册中心挂了可以继续通信吗?? dubbo当中的序列化协议有哪些? 简述一下你所知道的IO模型 dubbo复制均衡策略和高可用策略都有哪些? 为什么要进行系统拆分？拆分不用dubbo可以吗’dubbo和thrift什么区别啊? tomcat的httpServer是如何实现的？ Tomcat线程模型和IO模型 Tomcat系统参数认识和调优？ 为什么使用消息队列？消息队列有什么优点和缺点啊? 如何保证消息队列的高可用？如何保证消息不被重复消费？ spring都有哪些机制AOP底层如何实现IOC呢?? cgLib知道吗?JDK动态代理为什么只能使用接口？ 使用mysq1索引都有哪些原则? ?索引什么数据结构? 3+tree 和B tree 什么区别? 请介绍一下JVM内存模型?gc的算法？ 线上发送频繁full gc如何处理? CPU 使用率过高怎么办? MySQL的储引擎详细分析 高并发系统的数据库设计需要注意哪些？ 谈谈分布式事务如何架构？ 动态扩容缩容的分库分表怎么来设计？ 说说你了解到的分库分表中间件，以及他的原理 把一个未分库分表的系统切换成分库分表如何做？会遇到哪些问题? 分布式事务知道吗? 你们怎么解决的? 分库分表的优点是什么为什么要使用? 能不能手写一个RPC通信demo 分布式寻址方式都有哪些算法知道一致性hash吗?手写一下java实现代码??你若userId取摸分片，那我要查一段连续时间里的数据怎么办??? 如何解决分库分表主键问题有什么实现方案?? redis和ehcache有什么区别?为什么redis的性能那么高？ redis的数据类型和使用场景? reids的主从复制是怎么实现的redis的集群模式是如何实现的呢redis的key是如何寻址的啊? 使用redis如何设计分布式锁?使用zk可以吗?如何实现啊这两种哪个效率更高啊?? redis如何实现持久化的？ redis过期策略都有哪些? kafka ，activemq,rabbitmq ，rocketmq都有什么优点，缺点啊? 如果让你写一个消息队列，该如何进行架构设计啊?说一下你的思路 说一下TCP 'IP四层? http的工作流程？ http1.0 http1.1http2.0 具体哪些区别啊? TCP三次握手，四层分手的工作流程画一下流程图为什么不是四次五次或者二次啊? spring的源码中所用到的设计思想？ 系统架构如何选择合适日志技术（log4j、log4j2、slf4j、jcl…….） springAOP的原理，springAOP和Aspectj的关系，springAOP的源码问题 dubbo框架的底层通信原理 RPC通信原理，分布式通信原理 如何利用springCloud来架构微服务项目 如何正确使用docker技术 springMVC的底层原理、如何从源码来分析其原理 mybaits的底层实现原理，如何从源码来分析mybaits mysql的索引原理，索引是怎么实现的 索引的底层算法、如何正确使用、优化索引 springboot如何快速构建系统 zk原理知道吗zk都可以干什么Paxos算法知道吗?说一下原理和实现? 如果让你写一个消息队列，该如何进行架构设计啊?说一下你的思路 分布式事务知道吗? 你们怎么解决的? 请问你做过哪些JVM优化?使用什么方法达到什么效果?","categories":[{"name":"知识点","slug":"知识点","permalink":"https://ymagic.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"}],"tags":[{"name":"知识点","slug":"知识点","permalink":"https://ymagic.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"单例模式","slug":"单例模式","date":"2018-12-08T15:45:03.000Z","updated":"2022-08-25T06:32:57.445Z","comments":true,"path":"2018/12/08/dan-li-mo-shi/","link":"","permalink":"https://ymagic.github.io/2018/12/08/dan-li-mo-shi/","excerpt":"","text":"静态内部类 1234567891011public class Singletion&#123; private Singletion()&#123;&#125; public static Singletion getInstance()&#123; return SingletionHolder.INSTANCE; &#125; private static class SingletionHolder&#123; public static final Singletion INSTANCE = new Singletion(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://ymagic.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"https://ymagic.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Docker实践笔记二","slug":"Docker实践笔记","date":"2018-10-14T03:58:59.000Z","updated":"2022-08-25T06:34:10.608Z","comments":true,"path":"2018/10/14/docker-shi-jian-bi-ji/","link":"","permalink":"https://ymagic.github.io/2018/10/14/docker-shi-jian-bi-ji/","excerpt":"Ubuntu 16.04环境，实践docker","text":"Ubuntu 16.04环境，实践docker docker配置国内镜像地址 在/etc/docker/目录下添加daemon.json文件，内容如下： 123&#123;&quot;registry-mirrors&quot;:[&quot;https://registry.docker-cn.com&quot;]&#125; 然后重启docker daemon服务 1sudo service docker restart 安装MySQL 拉取MySQL镜像 1docker pull mysql:5.7.23 启动MySQL容器（设置密码、端口映射） 1docker run --name 实例名称 -p 3307:3306 -e MYSQL_ROOT_PASSWORD=密码 -d mysql:5.7.23 查看已经运行的docker镜像 1docker ps 连接到镜像中 1docker exec -it 镜像实例名 bash 查看MySQL状态 1service mysql status 连接MySQL，设置root账号和密码 123456mysql -uroot -puse mysql;update user set authentication_string=password(&#x27;new_password&#x27;) where user=&#x27;root&#x27;;mysql8.0以上版本使用如下修改密码alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;admin1234&#x27;; 由于mysql中的root执行绑定在了localhost，因此需要对root进行授权 1234grant all privileges on *.* to root@&#x27;%&#x27; identified by &#x27;password&#x27; with grant option;mysql8.0以上版本使用如下命令授权grant all on *.* to root@&#x27;%&#x27;; 刷新MySQL系统权限相关表 1flush privileges; 测试MySQL连接","categories":[{"name":"docker","slug":"docker","permalink":"https://ymagic.github.io/categories/docker/"},{"name":"笔记","slug":"docker/笔记","permalink":"https://ymagic.github.io/categories/docker/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ymagic.github.io/tags/docker/"},{"name":"笔记","slug":"笔记","permalink":"https://ymagic.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"镜像","slug":"镜像","permalink":"https://ymagic.github.io/tags/%E9%95%9C%E5%83%8F/"}]},{"title":"Docker实践笔记一：安装docker","slug":"Docker实践笔记一：安装docker","date":"2018-10-12T12:34:39.000Z","updated":"2022-08-25T06:34:20.195Z","comments":true,"path":"2018/10/12/docker-shi-jian-bi-ji-yi-an-zhuang-docker/","link":"","permalink":"https://ymagic.github.io/2018/10/12/docker-shi-jian-bi-ji-yi-an-zhuang-docker/","excerpt":"本文开发环境为Ubuntu16.04 LTS 64位系统，通过apt的docker官方源安装最新的Docker CE(Community Edition)，即Docker社区版。","text":"本文开发环境为Ubuntu16.04 LTS 64位系统，通过apt的docker官方源安装最新的Docker CE(Community Edition)，即Docker社区版。 针对Ubuntu Trusty, Wily, and Xenial，推荐安装linux-image-extra-*内核包，linux-image-extra-*包允许你使用aufs存储驱动 更新包管理器 1sudo apt-get update 安装推荐包 12sudo apt-get install linux-image-extra-$(uname -r) \\ linux-image-extra-virtual docker安装 1.卸载旧版本docker 由于apt官方库里的docker版本可能比较旧，所以先卸载可能存在的旧版本 1sudo apt-get purge docker docker-engine docker.io 2.更新系统软件 1sudo apt-get update 3.安装依赖包，使apt可以通过HTTPS使用存储库(repository) 12sudo apt-get install apt-transport-https ca-certificates \\ curl software-properties-common 4.添加Docker官方GPG密钥 执行该命令时，如遇到长时间没有响应说明网络连接不到docker网站，需要使用代理进行。 12curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \\ sudo apt-key add - 显示OK,表示添加成功. 5.添加仓库 1234sudo add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; 6.再次更新apt索引 1sudo apt-get update 7.安装docker 查看可用版本 1apt-cache madison docker-ce 安装指定版本 &lt;VERSION&gt;为版本号 1sudo apt-get install docker-ce=&lt;VERSION&gt; 安装最新版Docker CE 1sudo apt-get install docker-ce 8.查看docker版本 1docker -v 验证Docker 显示出版本信息，即安装成功。 查看docker服务是否启动 1sudo service docker status 若未启动，则启动docker服务 1sudo service docker start 确认docker已被正确安装 1sudo docker run hello-world 这个命令下载一个测试图片并且在容器(container)中运行，然后容器container运行，打印出相关信息，说明安装成功 创建docker group docker进程(daemon)绑定在Unix套接字(socket)，而不是TCP端口(port)，由于Unix默认socket权限归root用户所有，其他用户可以通过sudo访问. 由此, docker进程通常使用root用户运行. 为了避免每次使用docker命令都不得不使用sudo, 创建名为docker的Unix group并add users to it. 当docker daemon 开始,docker group就会拥有Unix socket 的读写权限（read/writable）. 为docker group 添加用户user 1.使用具有sudo权限的用户登录Ubuntu 2.创建docker group 1sudo groupadd docker 3.添加登录用户到docker group用户组中 1sudo gpasswd -a $USER docker 4.更新用户组 1newgrp docker 5.测试docker命令不用sudo是否可以正常使用 1docker ps","categories":[{"name":"docker","slug":"docker","permalink":"https://ymagic.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ymagic.github.io/tags/docker/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ymagic.github.io/tags/Ubuntu/"}]},{"title":"Docker命令使用详解","slug":"Docker命令使用详解","date":"2018-10-01T13:19:54.000Z","updated":"2022-08-25T06:33:48.673Z","comments":true,"path":"2018/10/01/docker-ming-ling-shi-yong-xiang-jie/","link":"","permalink":"https://ymagic.github.io/2018/10/01/docker-ming-ling-shi-yong-xiang-jie/","excerpt":"","text":"docker 容器生命周期管理 docker run docker run:创建一个新容器并运行 1docker run --name mysql2 -p 3307:3306 -e MYSQL_ROOT_PASSWORD=密码 -d mysql:5.7 以mysql:5.7镜像启动一个容器，指定容器名称为mysql2 映射端口号设置密码，并在后台运行 参数： 12345678910111213141516-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项-d: 后台运行容器，并返回容器ID-i: 以交互模式运行容器，通常与 -t 同时使用-p: 端口映射，格式为：主机(宿主)端口:容器端口-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用--name=&quot;nginx-lb&quot;: 为容器指定一个名称--dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致-h &quot;mars&quot;: 指定容器的hostname-e username=&quot;ritchie&quot;: 设置环境变量--env-file=[]: 从指定文件读入环境变量--cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定CPU运行-m :设置容器使用内存最大值--net=&quot;bridge&quot;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型--link=[]: 添加链接到另一个容器--expose=[]: 开放一个端口或一组端口 docker start/stop/restart docker start/stop/restart :启动、停止或重启一个或多个容器 1docker start $container_id 启动一个ID为$container_id的容器 参数： 123-a, --attach=false：启动一个容器并打印输出结果和错误-i, --interactive=false： 启动一个容器并进入交互模式-t, --time=10 ：停止或者重启容器的超时时间（秒），超时后系统将杀死进程。 docker kill docker kill :杀掉一个运行中的容器 1docker kill -s KILL 94c6b3c3f04a 杀死一个ID为 94c6b3c3f04a 的容器，并向容器中发送KILL信号 参数： 1-s, --signal=KILL ：自定义发送至容器的信号 docker rm ** docker rm ：删除一个或多少容器 ** 12docker rm harrysun/lnmpdocker rm -l webapp/redis 移除 harrysun/lnmp 的本地容器和移除 webapp/redis 容器的网络连接 参数： 123-f, --force=false ：强行移除该容器，即使其正在运行-l, --link=false ：移除容器间的网络连接，而非容器本身-v, --volumes=false ：移除与容器关联的空间 docker pause/unpause docker pause/unpause:暂停/恢复容器中的所有进程 1docker pause CONTAINER [CONTAINER...] docker create docker create:创建一个新容器但不启动它 1docker create --name myrunoob nginx:latest 使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob docker exec ** docker exec:在运行的容器中执行命令 ** 1docker exec -it mysql2 bash 以交互模式进入容器，并分配一个伪终端 参数： 123-d :分离模式: 在后台运行-i :即使没有附加也保持STDIN 打开-t :分配一个伪终端 容器操作 docker ps ** docker ps:列出容器 ** 1docker ps -a 列出所有容器 参数： 12345678-a :显示所有的容器，包括未运行的。-f :根据条件过滤显示的内容。--format :指定返回值的模板文件。-l :显示最近创建的容器。-n :列出最近创建的n个容器。--no-trunc :不截断输出。-q :静默模式，只显示容器编号。-s :显示总的文件大小。 docker inspect ** docker inspect:获取容器/镜像的元数据 ** 1docker inspect mysql:5.6 获取镜像mysql:5.6的元信息 1docker inspect 容器ID | grep IPAdress 查看容器ip 1docker inspect -f=&#x27;&#123;&#123;.Name&#125;&#125;&#x27; $(docker ps -a -q) 查看容器名称 1docker inspect -f=&#x27;&#123;&#123;.NetworkSetting.IPAddress&#125;&#125;&#x27; mymysql 查看容器mymysql的ip 1docker inspect -f=&#x27;&#123;&#123;.Name&#125;&#125; &#123;&#123;.NetworkSettings.IPAddress&#125;&#125; &#123;&#123;.HostConfig.PortBindings&#125;&#125;&#x27; $(docker ps -aq) 列出所有容器对应的名称，端口以及ip docker top docker top:查看容器中运行的进程信息，支持 ps 命令参数 1docker top [OPTIONS] CONTAINER [ps OPTIONS] 1docker top mymysql 查询容器mymysql的进程信息 docker events ** docker events:从服务器获取实时事件 ** 1docker events --since=&#x27;20180720&#x27; --until=&#x27;20180808&#x27; 显示docker 从2018/07/20到2018/08/08的所有事件 1docker events -f &#x27;image=mysql:5.6&#x27; --since=&#x27;20180720&#x27; 显示docker镜像为mysql:5.6 20180720以后的所有事件 参数： 123-f ：根据条件过滤事件；--since ：从指定的时间戳后显示所有事件;--until ：流水时间显示到指定的时间为止； docker logs ** docker logs : 获取容器的日志 ** 1docker logs -f mysql5 跟踪查看容器mysql5的日志输出 1docker logs --since=&#x27;20180701&#x27; --tail=10 mysql5 查看容器mysql5从2018/07/01以后的最新10条日志 参数： 1234-f : 跟踪日志输出--since :显示某个开始时间的所有日志-t : 显示时间戳--tail :仅列出最新N条容器日志","categories":[{"name":"docker","slug":"docker","permalink":"https://ymagic.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ymagic.github.io/tags/docker/"}]},{"title":"Ubuntu16.04 开机黑屏","slug":"Ubuntu16.04 开机黑屏","date":"2018-09-11T02:49:32.000Z","updated":"2022-08-25T06:36:39.341Z","comments":true,"path":"2018/09/11/ubuntu16.04-kai-ji-hei-ping/","link":"","permalink":"https://ymagic.github.io/2018/09/11/ubuntu16.04-kai-ji-hei-ping/","excerpt":"描述 Ubuntu 16.04 在改用NVIDIA的专有显卡驱动后，开机黑屏","text":"描述 Ubuntu 16.04 在改用NVIDIA的专有显卡驱动后，开机黑屏 原因 桌面在运行时，显卡驱动不能安装 解决 开机时按Ctrl+Alt+F1进入tty命令行模式，执行 12sudo apt-get purge nvidia*sudo apt-get install nvidia-current-updates-dve","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ymagic.github.io/categories/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ymagic.github.io/tags/Ubuntu/"}]},{"title":"Ubuntu 小技巧","slug":"Ubuntu-小技巧","date":"2018-09-03T02:54:31.000Z","updated":"2022-08-25T06:36:31.362Z","comments":true,"path":"2018/09/03/ubuntu-xiao-ji-qiao/","link":"","permalink":"https://ymagic.github.io/2018/09/03/ubuntu-xiao-ji-qiao/","excerpt":"在此记录我在使用 Ubuntu 16.04的过程中出现的问题，及解决方法","text":"在此记录我在使用 Ubuntu 16.04的过程中出现的问题，及解决方法 #依赖问题 使用 dpkg -i *.deb 的时候出现依赖没有安装 使用 apt-get -f -y install 解决依赖问题后再执行dpkg安装deb包 Error while loading shared libraries: libgthread-2.0.so.0 Step 1: Find the package that includes this library 1dpkg -S libgthread-2.0.so.0 libglib2.0-0:amd64: /usr/lib/x86_64-linux-gnu/libgthread-2.0.so.0 Step 2: Install 32 bit version of the same so add i386 instead of amd 64. 1apt-get install libglib2.0-0:i386 测网速 1speedtest-cli 检测丢包率 1mtr -r -c 30 -s 1024 www.baidu.com 向百度发送数据包 每秒30个 每个1024个字节 mtr -h 提供帮助命令 mtr -v 显示mtr的版本信息 mtr -r 已报告模式显示 mtr -c 设置每秒发送数据包的数量 mtr -s 用来指定ping数据包的大小 mtr -n no-dns不对IP地址做域名解析 mtr -a 来设置发送数据包的IP地址 这个对一个主机由多个IP地址是有用的 mtr -i 使用这个参数来设置ICMP返回之间的要求默认是1秒 mtr -4 IPv4 mtr -6 IPv6 依赖问题 使用dpkg -i *.deb 的时候出现依赖没有安装 使用apt-get -f -y install 解决依赖问题后再执行dpkg安装deb包 最小化 1gsettings set org.compiz.unityshell:/org/compiz/profiles/unity/plugins/unityshell/ launcher-minimize-window true 点击Launcher 图标最小化 禁止开机自启动 1systemctl disable mysql 或者 1sudo update-rc.d mysql disable dpkg 和 apt-get损坏修复 使用apt-get 或者dpkg安装包时，出现以下报错 subprocess installed post-installation script returned error exit status 10 解决办法： 到 /var/lib/dpkg/info 目录下，删除以上出现包名字开头的文件后，执行 sudo apt-get -f install E: Sub-process /usr/bin/dpkg returned an error code (1) 解决办法： sudo mv /var/lib/dpkg/info /var/lib/dpkg/info_old //现将info文件夹更名 sudo mkdir /var/lib/dpkg/info //再新建一个新的info文件夹 sudo apt-get update,再$sudoapt-get -f install sudo mv /var/lib/dpkg/info/* /var/lib/dpkg/info_old //执行完上一步操作后会在新的info文件夹下生成一些文件，现将这些文件全部移到info_old文件夹下 sudo rm -rf /var/lib/dpkg/info //把自己新建的info文件夹删掉 sudo mv /var/lib/dpkg/info_old /var/lib/dpkg/info //把以前的info文件夹重新改回名字 到此问题顺利解决","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ymagic.github.io/categories/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ymagic.github.io/tags/Ubuntu/"}]},{"title":"SpringBoot 定时任务","slug":"SpringBoot-定时任务","date":"2018-03-01T05:58:03.000Z","updated":"2022-08-25T06:36:13.980Z","comments":true,"path":"2018/03/01/springboot-ding-shi-ren-wu/","link":"","permalink":"https://ymagic.github.io/2018/03/01/springboot-ding-shi-ren-wu/","excerpt":"定时任务实现的几种方式： Timer：这是java自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。使用这种方式可以让你的程序按照某一个频度执行，但不能在指定时间运行。一般用的较少。 ScheduledExecutorService：也jdk自带的一个类；是基于线程池设计的定时任务类,每个调度任务都会分配到线程池中的一个线程去执行,也就是说,任务是并发执行,互不影响。 Spring Task：Spring3.0以后自带的task，可以将它看成一个轻量级的Quartz，而且使用起来比Quartz简单许多。 Quartz：这是一个功能比较强大的的调度器，可以让你的程序在指定时间执行，也可以按照某一个频度执行，配置起来稍显复杂。","text":"定时任务实现的几种方式： Timer：这是java自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。使用这种方式可以让你的程序按照某一个频度执行，但不能在指定时间运行。一般用的较少。 ScheduledExecutorService：也jdk自带的一个类；是基于线程池设计的定时任务类,每个调度任务都会分配到线程池中的一个线程去执行,也就是说,任务是并发执行,互不影响。 Spring Task：Spring3.0以后自带的task，可以将它看成一个轻量级的Quartz，而且使用起来比Quartz简单许多。 Quartz：这是一个功能比较强大的的调度器，可以让你的程序在指定时间执行，也可以按照某一个频度执行，配置起来稍显复杂。 SpringBoot 整合 Quartz 添加依赖 我使用的SpringBoot版本是2.0.0以上版本，在 spring-boot-starter 中已经包含了quartz的依赖，则可以直接使用 spring-boot-starter-quartz 依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;&lt;/dependency&gt; 创建任务类TestQuartz, 该类主要继承了QuartzJobBean 123456public class TestQuartz extends QuartzJobBean &#123; @Override protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; System.out.println(&quot;quartz task &quot;+new Date()); &#125;&#125; 创建配置类QuartzConfig 1234567891011121314151617@Configurationpublic class QuartzConfig &#123; @Bean public JobDetail testQuartzDetail() &#123; return JobBuilder.newJob(TestQuartz.class).withIdentity(&quot;testQuartz&quot;).storeDurably().build(); &#125; @Bean public Trigger testQuartzTrigger() &#123; SimpleScheduleBuilder schedulebuilder = SimpleScheduleBuilder.simpleSchedule() .withIntervalInSeconds(10) //设置时间周期单位秒 .repeatForever(); return TriggerBuilder.newTrigger().forJob(testQuartzDetail()) .withIdentity(&quot;testQuartz&quot;) .withSchedule(schedulebuilder) .build(); &#125;&#125; 启动项目","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ymagic.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ymagic.github.io/tags/SpringBoot/"},{"name":"Quartz","slug":"Quartz","permalink":"https://ymagic.github.io/tags/Quartz/"}]},{"title":"排序算法","slug":"排序算法","date":"2018-03-01T02:11:31.000Z","updated":"2022-08-25T06:33:40.833Z","comments":true,"path":"2018/03/01/pai-xu-suan-fa/","link":"","permalink":"https://ymagic.github.io/2018/03/01/pai-xu-suan-fa/","excerpt":"","text":"插入排序 123456789101112131415161718192021/** * 插入排序 * @param array * @return arr */public static int[] insertSort(int[] array) &#123; //对array进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(array, array.length); for (int i = 1; i &lt; arr.length; i++) &#123; int temp = arr[i]; for (int j = i - 1; j &gt;= 0; j--) &#123; if (arr[j] &gt; temp) &#123; arr[j + 1] = arr[j]; &#125; else &#123; arr[j + 1] = temp; break; &#125; &#125; &#125; return arr;&#125; 冒泡排序 12345678910111213141516171819202122232425262728293031323334/** * 冒泡排序 * @param array * @return */public static int[] bubbleSort(int[] array) &#123; int[] arr = Arrays.copyOf(array, array.length); int temp; //记录最后一次交换的位置 int lastExchangeIndex = 0; //无序边界的位置，每次只需要比较到这里为止 int sortBorder = arr.length - 1; for (int i = 0; i &lt; arr.length; i++) &#123; //有序标记，每一轮的初始值为true,有交换则改为false boolean isSorted = true; for (int j = 0; j &lt; sortBorder; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; //有元素交换，所以不是有序，标记变为false isSorted = false; //把无序数列的边界更新为最后一次交换元素的位置 lastExchangeIndex = j; &#125; &#125; sortBorder = lastExchangeIndex; //如果没有减缓，数组就是有序的，跳出循环 if (isSorted) &#123; break; &#125; &#125; return arr;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://ymagic.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"算法/排序","permalink":"https://ymagic.github.io/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://ymagic.github.io/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"缓存","slug":"缓存","permalink":"https://ymagic.github.io/categories/%E7%BC%93%E5%AD%98/"},{"name":"homebrew","slug":"homebrew","permalink":"https://ymagic.github.io/categories/homebrew/"},{"name":"mac","slug":"mac","permalink":"https://ymagic.github.io/categories/mac/"},{"name":"openjdk","slug":"mac/openjdk","permalink":"https://ymagic.github.io/categories/mac/openjdk/"},{"name":"mac快捷键","slug":"mac快捷键","permalink":"https://ymagic.github.io/categories/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"iTerm2","slug":"mac快捷键/iTerm2","permalink":"https://ymagic.github.io/categories/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/iTerm2/"},{"name":"idea","slug":"mac快捷键/idea","permalink":"https://ymagic.github.io/categories/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/idea/"},{"name":"浏览器","slug":"mac快捷键/浏览器","permalink":"https://ymagic.github.io/categories/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://ymagic.github.io/categories/SpringCloud/"},{"name":"sql优化","slug":"sql优化","permalink":"https://ymagic.github.io/categories/sql%E4%BC%98%E5%8C%96/"},{"name":"hexo","slug":"hexo","permalink":"https://ymagic.github.io/categories/hexo/"},{"name":"流量控制","slug":"流量控制","permalink":"https://ymagic.github.io/categories/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"},{"name":"限流","slug":"流量控制/限流","permalink":"https://ymagic.github.io/categories/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/%E9%99%90%E6%B5%81/"},{"name":"Redis","slug":"Redis","permalink":"https://ymagic.github.io/categories/Redis/"},{"name":"缓存","slug":"Redis/缓存","permalink":"https://ymagic.github.io/categories/Redis/%E7%BC%93%E5%AD%98/"},{"name":"java 8","slug":"java-8","permalink":"https://ymagic.github.io/categories/java-8/"},{"name":"知识点","slug":"知识点","permalink":"https://ymagic.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"设计模式","slug":"设计模式","permalink":"https://ymagic.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"docker","slug":"docker","permalink":"https://ymagic.github.io/categories/docker/"},{"name":"笔记","slug":"docker/笔记","permalink":"https://ymagic.github.io/categories/docker/%E7%AC%94%E8%AE%B0/"},{"name":"Linux","slug":"Linux","permalink":"https://ymagic.github.io/categories/Linux/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ymagic.github.io/categories/SpringBoot/"},{"name":"算法","slug":"算法","permalink":"https://ymagic.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"算法/排序","permalink":"https://ymagic.github.io/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"https://ymagic.github.io/tags/%E7%BC%93%E5%AD%98/"},{"name":"homebrew","slug":"homebrew","permalink":"https://ymagic.github.io/tags/homebrew/"},{"name":"mac","slug":"mac","permalink":"https://ymagic.github.io/tags/mac/"},{"name":"openjdk","slug":"openjdk","permalink":"https://ymagic.github.io/tags/openjdk/"},{"name":"mac快捷键","slug":"mac快捷键","permalink":"https://ymagic.github.io/tags/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"iTerm2","slug":"iTerm2","permalink":"https://ymagic.github.io/tags/iTerm2/"},{"name":"idea","slug":"idea","permalink":"https://ymagic.github.io/tags/idea/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://ymagic.github.io/tags/SpringCloud/"},{"name":"nacos","slug":"nacos","permalink":"https://ymagic.github.io/tags/nacos/"},{"name":"sql优化","slug":"sql优化","permalink":"https://ymagic.github.io/tags/sql%E4%BC%98%E5%8C%96/"},{"name":"hexo","slug":"hexo","permalink":"https://ymagic.github.io/tags/hexo/"},{"name":"流量控制","slug":"流量控制","permalink":"https://ymagic.github.io/tags/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"},{"name":"限流","slug":"限流","permalink":"https://ymagic.github.io/tags/%E9%99%90%E6%B5%81/"},{"name":"Redis","slug":"Redis","permalink":"https://ymagic.github.io/tags/Redis/"},{"name":"java8","slug":"java8","permalink":"https://ymagic.github.io/tags/java8/"},{"name":"Lambda","slug":"Lambda","permalink":"https://ymagic.github.io/tags/Lambda/"},{"name":"知识点","slug":"知识点","permalink":"https://ymagic.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"单例模式","slug":"单例模式","permalink":"https://ymagic.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"docker","slug":"docker","permalink":"https://ymagic.github.io/tags/docker/"},{"name":"笔记","slug":"笔记","permalink":"https://ymagic.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"镜像","slug":"镜像","permalink":"https://ymagic.github.io/tags/%E9%95%9C%E5%83%8F/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ymagic.github.io/tags/Ubuntu/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ymagic.github.io/tags/SpringBoot/"},{"name":"Quartz","slug":"Quartz","permalink":"https://ymagic.github.io/tags/Quartz/"},{"name":"算法","slug":"算法","permalink":"https://ymagic.github.io/tags/%E7%AE%97%E6%B3%95/"}]}